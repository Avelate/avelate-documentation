# Пятизвённая архитектура

1. Клиент состоит из:
    1.1. Клиентская бизнес-логика - описывает дисплеи, компоненты и бизнес-логики, которая относится к конкретному бизнес-приложению.
    1.2. Клиентское ядро - описывает абстрактный функционал, который может быть переиспользован в различных бизнес-приложениях.

2. Сервер рендеринга - отвечает за фоновую генерацию статический страниц в случае SSG, пререндер и SSR, а также выступает Proxy для CSR.

3. Сервер вычислений состоит из:
    3.1. Серверное ядро - описывает абстрактный функционал, который может быть переиспользован в различных серверных бизнес-приложениях.
    3.2. Серверная бизнес-логика - описывает доменные области конкретных сущностей, который относятся к конкретному бизнес-приложению.


## Клиент

Клиент состоит из двух частей - бизнес-логики и ядра

### Бизнес логика

Бизнес логика состоит из:
    - Шаблонов - описывающие структуру страницы.
    - Дисплеи - являются или полноценными страницами или лишь контентом в рамках конкретного шаблона.
    - Ассеты - статические файлы, которые не будут изменены в рамках жизни приложения.
    - Компоненты - основные блоки любого дисплея или шаблона.

### Клиентское ядро

Ядро описывает функционал:
    - работу с веб-сокетами
    - работа с переводами
    - работа с IndexDB / LocalStorage / SessionStorage
    - оперирование сессий
    - обработка токенов
    - и т.д.

## Сервер рендеринга

Сервер рендеринга отвечает за:
    - Server Side Rendering
    - Server Site Generation
    - Proxy for Client Side Rendering

Помимо основних задач, сервер также:
    - Ведёт активный мониторинг с помощью Prometheus + Grafana.
    - Пишет логи в Elasticsearct / logstash / kibana.
    - Пишет логи в файли и в консоль.
    - Пишет ошибки в Sentry.
    - Измеряет производительность каждого запроса с помощью Jaeger.
    - Основан на stateless микросервисах работающий через NATS.
    - Поддерживает переменные окружения и их изменения без перезагрузки сервера.
    - Поддержка кеширования HTML блоков с помощью Redis
    - Отдача статики и контроль её через Redis с помощью валидации кеша и графа зависимостей этого кеша.
    - Поддерживает основные паттерны отказоустойчивости: 
        - Rate limit с помощью Sliding Window
        - Deadlines
        - Circuit Breaker
        - Retry

## Сервер вычислений

### Серверная бизнес-логика

Бизнес-логика состоит из:
    - доменных областей, которые описывает структуру бази данных, обработчики и маршруты конкретной доменной области.
    - функционал связанный с чат ботами
    - т.д.

### Серверное ядро

Ядро состоит из:
    - 


## Основные задачи каждого элемента

Сервер рендеринг должен:
- Обрабатывать рендеринг SSG / SSR и перенаправлять запросы CSR на сервер вычислений.
- Иметь богатый инструментарий для мониторинга состояния сервера.
- Быть децентрализирован с помощью микросервисов и поддерживать динамическое горизонтальное масштабирования
- Иметь гарячее резервирования балансировщика нагрузки
- Уметь работать с кешем
- Формировать общую схему бизнес-логики, которая состоит из следующей иерархии --> микрофронтенд --> дисплеи или шаблоны
- Обрабатывать и отдавать статику
- Каждый микросервис должен быть развёрнут с помощью Docker в кластере Kubernetes
- Инфраструктура приложения должна быть описана через Terraform 
- Сценарии запуска и развёртывания инфраструктуры и поднятия сервера должны быть описаны через Ansible
- Система должна поддерживать автоматические обновления и выкладку с помощью подробного CI / CD пайплайнов.
- Система должна уметь быстро разворачиватся
- Система должна автоматические реагировать на нагрузку и автоматически поднимать или удалять экземпляры конкретного микросервиса

Клиент должен быть:
- Поддерживать обновления и догрузку в фоновом режиме с помощью Websocket
- Уметь переключаться с SSR на CSR 
- Уметь переключаться с SSG на CSR 
- Обрабатывать пререндеры
- Поддерживать микрофронтенды
- Работать с рич текст эдиторами, звуковыми дорожками и видео
- Работать с картами
- Должен быть спроектирован из маленьких кусочков:
  - деление на микрофронтенды
  - иметь раздельный стор
  - иметь раздельные бандлы и иметь различные типы лоадеров - лейзи или обычный
  - библиотеки должны быть выбраны по принципы - установка базового ядра и подтягивание только использующегося дополнения к ядру, а не всю библиотеку
